## Design Crew Architecture Plan

**Input:** The **complete 'Blueprint' document** generated. No other information source should be used.

**Process:** Based *solely* on the **complete and detailed 'Blueprint'**, design the optimal CrewAI configuration. This involves developing specifications for tasks, agents, and tools. Define all tool configurations and custom tools centrally, then reference them in tasks. Ensure all aspects of the Blueprint are addressed.

**Output:** A 'Design-Crew-Architecture-Plan' document. This document is a structured representation generated by the AI, containing all sections defined below. It serves as the **direct and complete input** for the script construction. It must contain all specifications and configurations required for script construction to proceed without referring back to the initial Blueprint.

**'Design-Crew-Architecture-Plan' - Mandatory Sections:**

**A. Workflow Process:**
*   Selected Process: `Process.sequential` OR `Process.hierarchical`.
*   Justification: Explain WHY this process is optimal for the 'Blueprint's Execution Outline'.
*   Manager LLM Specification (If `Process.hierarchical`):
    *   `model`: Selected model name (e.g., 'gemini/gemini-2.5-pro-preview-05-06'). MUST be from Approved LLM List (see Script Construction).
    *   `temperature`: **MUST BE 0.0**.
    *   `api_key`: (Optional) Environment variable name for the API key.
    *   `config_params`: (Optional) Specific configuration dictionary for the LLM.
    *   `multimodal`: (Optional, default `False`) `True` if the manager LLM needs multimodal capabilities.
    *   Rationale: Justify the choice of this manager LLM and its `multimodal` setting (if `True`).

**B. Agent Cadre:** For EACH agent, define:
*   Role: Concise functional title.
*   Goal: Specific objective aligned with the 'Blueprint'.
*   Backstory: Narrative reinforcing expertise for the Goal.
*   LLM Specification:
    *   `model`: Selected model name (e.g., 'gemini/gemini-2.5-flash-preview-05-20'). MUST be from the 'Approved LLM List' (see Script Construction).
    *   `temperature`: **MUST BE 0.0**.
    *   `api_key`: (Optional) Environment variable name for the API key.
    *   `config_params`: (Optional) Any specific configuration dictionary required for the LLM.
    *   `multimodal`: (Optional, default `False`) `True` if this agent's LLM needs multimodal capabilities.
*   LLM Rationale: Justify the choice of THIS specific model for THIS agent's Role and Goal, referencing its capabilities (e.g., reasoning, generation, speed, multimodal support) relevant to the 'Blueprint'.
*   Tools (Agent's Toolkit): List general tool *types/capabilities* (e.g., Web Search, File Writing, PDF Text Extraction) this agent is expected to leverage. The specific tool *instances* an agent uses will be derived from the 'Enabling Tool(s)' of the tasks assigned to it.
*   Tool Rationale (Agent Level): Explain WHY this overall toolkit (as a collection of capabilities) is essential for this agent.
*   `allow_delegation`: `True` or `False`.
*   Delegation Rationale: Justify the choice for `allow_delegation`.

**C. Tool Configuration Repository:** (Defines all unique tool configurations)
*   For EACH unique tool configuration:
    *   `config_id`: A unique identifier/variable name for this tool configuration (e.g., 'serper_search_main', 'report_writer_tool', 'pdf_text_extractor').
    *   `tool_type`: The CrewAI tool class (e.g., 'SerperDevTool', 'FileWriterTool') or the `class_name` of a custom tool (defined in Section D).
    *   `is_custom_tool`: `True` if `tool_type` refers to a class name from Section D, `False` otherwise.
    *   `tool_selection_justification`: Based on the 'Blueprint's' information assets (especially file types and processing needs like "extract all text from PDF") and execution outline, justify why this specific `tool_type` (and its configuration) is chosen.
        *   If it's a standard CrewAI tool (e.g., `SerperDevTool`, `FileWriterTool`, `WebsiteSearchTool`, `PDFSearchTool`), explain its suitability for the required input/output.
        *   If a custom tool is being proposed (`is_custom_tool: True`), this justification must clearly state why no standard CrewAI tool (even with varied configurations) can meet the specific requirements (e.g., `FileReadTool` for non-plain-text files like PDFs, `PDFSearchTool` being for Q&A not full text extraction when "extract all text" is needed).
    *   `initialization_params`: A dictionary of parameters for initializing the tool instance in the script.
        *   For API keys, specify the environment variable name (e.g., `{'api_key': 'SERPER_API_KEY'}`).
        *   **RAG Tool Configuration (If this `tool_type` is a RAG tool like `WebsiteSearchTool`, `PDFSearchTool`, `CSVSearchTool`, or a custom RAG tool):** This `initialization_params` dictionary MUST include the `config` dictionary for LLM/embedder.
            ```python
            # Example for initialization_params of a RAG tool:
            # {
            #   "source_identifier": "https://example.com", # Or file_path, etc.
            #   "config": { # RAG config dictionary
            #     "llm": {
            #         "provider": "google", # Or other provider
            #         "config": {
            #             "model": "gemini/gemini-2.5-flash-preview-05-20", # Must be from approved list or justified
            #             "temperature": 0.0,
            #             # "multimodal": False, # If applicable
            #             # "api_key": "GOOGLE_API_KEY" # If needed
            #         },
            #     },
            #     "embedder": {
            #         "provider": "ollama", # Or other provider
            #         "config": {
            #             "model": "nomic-embed-text:latest",
            #         },
            #     },
            #   }
            # }
            ```
            *   Rationale for RAG: Provide rationale for LLM (temp=0.0, ideally approved list or justified if specialized, consider multimodal) and embedder model choices within this RAG config.
    *   `input_data_requirements`: General description of the expected input data format, type, and source for this tool configuration (e.g., 'text string', 'local PDF file path given by user', 'URL').
    *   `output_data_requirements`: General description of the expected output data format and type from this tool configuration (e.g., 'markdown string', 'JSON object', 'file path of written content').

**D. Custom Tool Definitions:** (Define ONLY if `tool_selection_justification` in Section C determines a custom tool is necessary)
*   Condition: A custom tool is proposed ONLY if no built-in `crewai_tool` (analyzed first via Section C) can perform a critical 'Blueprint' function (e.g., "extract all text from a PDF" might require a custom tool if `PDFSearchTool` is unsuitable for that specific goal).
*   For EACH custom tool:
    *   `class_name`: Python class name (e.g., 'PDFTextExtractorTool'). This `class_name` is used as `tool_type` in Section C.
    *   `tool_name_attr`: The 'name' attribute for the tool (e.g., 'PDF Full Text Extractor').
    *   `description_attr`: The 'description' attribute for the tool.
    *   `args_schema_class_name`: (Optional) Pydantic model class name (defined in Section F) for input arguments.
    *   `_run_method_signature`: Define the signature, e.g., `def _run(self, file_path: str) -> str:`.
    *   `_run_method_logic_description`: Detailed textual description of the `_run` method, including libraries to use (e.g., `PyMuPDF` for PDF text extraction), and error handling.
    *   `justification_for_custom_tool`: Explicitly state why this custom tool is essential, referencing specific requirements from the 'Blueprint' (e.g., "Blueprint requires extracting all raw text from `main.pdf`. Standard `FileReadTool` cannot process PDFs. `PDFSearchTool` is for Q&A, not full text extraction. A custom tool using `PyMuPDF` is needed to meet this specific 'extract all text' requirement."). This information MUST be passed for inclusion as comments in the final script.

**E. Task Roster:** Detail EACH task. At least ONE task **MUST** produce the final 'Deliverable(s)'.
*   Task Identifier: Unique name (e.g., `pdf_extraction_task`, `analysis_task`).
*   Description: Detailed operational prompt for the agent, derived from 'Blueprint's Execution Outline'.
*   Assigned Agent Role: The `Role` of the designated agent (from Section B).
*   Expected Output: Clear definition of what this task produces (e.g., "A string containing all extracted text from the PDF.", "A markdown report with sections X, Y, Z.").
    *   If this task produces one of the 'Blueprint's Deliverable(s)', specify the filename and format here.
    *   If structured output is required and validated, reference an `output_pydantic_model` (see below).
*   Enabling Tool(s):
    *   List one or more `config_id`(s) from Section C that this task will use.
    *   For each `config_id`, optionally specify:
        *   `task_specific_expected_input`: (Optional) Clarification if the tool's input for *this specific task* needs further detail beyond `input_data_requirements` in Section C.
        *   `task_specific_expected_output`: (Optional) Clarification if the tool's output for *this specific task* needs further detail beyond `output_data_requirements` in Section C.
*   Tool Rationale (Task Level): Justify WHY these specific tool configurations (referenced by `config_id`) are most effective for THIS task. This rationale **MUST** compare the task's input/output needs (derived from Blueprint's Execution Outline) with the `input_data_requirements` and `output_data_requirements` of the chosen tool(s) from Section C. Reiterate why standard tools are chosen or why a custom tool (via its `config_id`) is necessary for this task's specific function.
*   Context: List prerequisite task *identifiers*, if any.
*   `output_pydantic_model`: (Optional) `class_name` of a Pydantic model from Section F if this task's output should be an instance of that model.
*   `output_pydantic_model_rationale`: (If `output_pydantic_model` is used) Justify why Pydantic validation/structure is beneficial for this specific task's output (e.g., "Ensures the analysis result is always in the correct structured format for downstream tasks or final deliverable.").

**F. Structured Data Handling (Pydantic):**
*   Usage: "Yes" or "No".
*   Rationale (If "Yes"): Explain HOW Pydantic models will enhance data integrity, inter-task communication (by providing clear data contracts for task outputs via `output_pydantic_model` in Section E), or structure final deliverables for THIS 'Blueprint'.
*   Model Definitions (If "Yes"): For each Pydantic model:
    *   `class_name`: Python class name (e.g., `AnalysisResultModel`).
    *   `fields`: A dictionary of field names to their Python types (e.g., `{'report_title': 'str', 'score': 'float', 'findings': 'List[str]'}`).

**G. Crew Memory:**
*   Activation: "Yes" or "No" for `memory=True` in the Crew object.
*   Rationale (If "Yes"): Explain WHY memory is crucial for THIS 'Blueprint's Primary Objective'.

**H. Memory Embedder (If Crew Memory is Active):**
*   Condition: If `memory=True`.
*   Configuration: Specify the dictionary structure for the `embedder` parameter in the Crew object.
    ```python
    # embedder_config_for_crew = {
    #     "provider": "ollama", # Or other provider
    #     "config": {
    #         "model": "nomic-embed-text:latest", # Specify model
    #         # "url": "http://localhost:11434/api/", # If applicable
    #     }
    # }
    ```
*   Rationale: Provide rationale for embedder model choice and provider.

**I. Internal Review Checklist (Perform this self-correction):**
*   **Blueprint Adherence:** Does this Plan fully address ALL 'Blueprint' requirements (Primary Objective, Deliverables, Information Assets including file processing needs, Execution Outline details)?
*   **Tooling Strategy:**
    *   Centralization: Are ALL tool configurations uniquely defined in 'Tool Configuration Repository' (Section C)? Are ALL custom tool structures defined in 'Custom Tool Definitions' (Section D)?
    *   Justification: Is `tool_selection_justification` in Section C robust for each tool, clearly explaining standard vs. custom choices based on Blueprint's input/output/file processing needs?
    *   Task Assignment: Do tasks in 'Task Roster' (Section E) correctly reference `config_id`s? Is 'Tool Rationale (Task Level)' clear, justifying tool choices against task requirements and the tool's specified `input_data_requirements`/`output_data_requirements`?
    *   Custom Tool Necessity: If custom tools are used, is `justification_for_custom_tool` in Section D compelling, confirming no standard tool (from `crewai_tools` or other configurations in Section C) is adequate for the specific function described in the Blueprint (e.g., "extract all text from PDF")?
*   **Output Path & Format:** Is the path to 'Blueprint's Deliverable(s)' via a specific task's output clear? Are output formats (including Pydantic models via `output_pydantic_model`) for tasks clearly defined where necessary?
*   **LLM Compliance:** Are ALL LLMs (agents, manager, RAG LLMs) specified with `temperature=0.0`? Are agent/manager LLMs from the approved list? Is `multimodal` considered and justified if `True`?
*   **Pydantic Usage:** If Pydantic models are used (Section F "Yes"), is their application justified and correctly linked to task outputs (`output_pydantic_model` in Section E)?
*   **Data Flow & Context:** Is inter-task data flow clear? Are task contexts correctly defined?
*   **Completeness for Script Construction:** Does this plan contain ALL information (LLM configs including `multimodal`, tool configs including RAG and input/output requirements, agent/task details, custom tool logic descriptions and justifications, Pydantic models) needed to write the script without referring back to the initial Blueprint?
*   **Efficiency:** Is the design appropriately complex? Are tools efficiently reused via the central repository?